// Service.hpp

// ... 其他代码 ...

static void Download(struct evhttp_request *req, void *arg)
{
    // 1. 获取客户端请求的资源路径path req.path
    // 2. 根据资源路径，获取StorageInfo
    StorageInfo info;
    std::string resource_path = evhttp_uri_get_path(evhttp_request_get_evhttp_uri(req));
    resource_path = UrlDecode(resource_path);
    data_->GetOneByURL(resource_path, &info);
    mylog::GetLogger("asynclogger")->Info("request resource_path:%s", resource_path.c_str());

    // ... 解压缩逻辑不变 ...
    std::string download_path = info.storage_path_;
    // (解压代码省略)

    FileUtil fu(download_path);
    if (!fu.Exists()) {
        // 文件不存在的错误处理
        evhttp_send_reply(req, HTTP_NOTFOUND, "File Not Found", NULL);
        return;
    }

    // 3.确认文件是否需要断点续传
    bool retrans = false;
    const char* if_range_header = evhttp_find_header(req->input_headers, "If-Range");
    if (if_range_header != nullptr)
    {
        if (std::string(if_range_header) == GetETag(info))
        {
            retrans = true;
            mylog::GetLogger("asynclogger")->Info("%s matches If-Range, ready for retransmission", download_path.c_str());
        }
    }

    // 4. 读取文件数据
    evbuffer *outbuf = evhttp_request_get_output_buffer(req);
    int fd = open(download_path.c_str(), O_RDONLY);
    if (fd == -1) {
        // 打开文件失败处理
        evhttp_send_reply(req, HTTP_INTERNAL, "Could not open file", NULL);
        return;
    }

    // 5. 设置通用响应头部
    evhttp_add_header(req->output_headers, "Accept-Ranges", "bytes");
    evhttp_add_header(req->output_headers, "ETag", GetETag(info).c_str());
    evhttp_add_header(req->output_headers, "Content-Type", "application/octet-stream");

    // 6. 根据是否断点续传，进行不同处理
    if (retrans) {
        // --- 开始处理 Range ---
        const char* range_header = evhttp_find_header(req->input_headers, "Range");
        if (range_header == nullptr) {
            // 如果客户端声称要断点续传 (If-Range)，但没有提供 Range，则视为无效请求或发送整个文件
             retrans = false; // 退化为完整下载
        } else {
            std::string range_str(range_header);
            std::smatch match;
            std::regex range_regex("bytes=(\\d+)-(\\d*)");
            long long start_byte = 0, end_byte = -1;

            if (std::regex_search(range_str, match, range_regex) && !match[1].str().empty()) {
                start_byte = std::stoll(match[1].str());
                if (match.size() > 2 && !match[2].str().empty()) {
                    end_byte = std::stoll(match[2].str());
                }

                int64_t total_size = fu.FileSize();
                if (end_byte == -1 || end_byte >= total_size) {
                    end_byte = total_size - 1;
                }
                long long content_length = end_byte - start_byte + 1;

                if (start_byte >= total_size || content_length <= 0) {
                     // 请求范围不合法
                    evhttp_add_header(req->output_headers, "Content-Range", ("bytes */" + std::to_string(total_size)).c_str());
                    evhttp_send_reply(req, 416, "Range Not Satisfiable", NULL);
                    close(fd);
                    return;
                }

                // 添加 Content-Range 头
                std::string cr_str = "bytes " + std::to_string(start_byte) + "-" + std::to_string(end_byte) + "/" + std::to_string(total_size);
                evhttp_add_header(req->output_headers, "Content-Range", cr_str.c_str());

                // 发送指定部分的文件
                if (-1 == evbuffer_add_file(outbuf, fd, start_byte, content_length)) {
                    mylog::GetLogger("asynclogger")->Error("evbuffer_add_file partial content error: %s", strerror(errno));
                }

                // 发送 206 响应
                evhttp_send_reply(req, 206, "Partial Content", NULL);
                mylog::GetLogger("asynclogger")->Info("Sent partial content (206) for %s", download_path.c_str());

            } else {
                 retrans = false; // Range 格式不正确，退化为完整下载
            }
        }
    }
    
    // 如果不是断点续传或断点续传处理失败，则执行完整下载
    if (!retrans) {
        if (-1 == evbuffer_add_file(outbuf, fd, 0, fu.FileSize())) {
            mylog::GetLogger("asynclogger")->Error("evbuffer_add_file full content error: %s", strerror(errno));
        }
        evhttp_send_reply(req, HTTP_OK, "OK", NULL);
        mylog::GetLogger("asynclogger")->Info("Sent full content (200) for %s", download_path.c_str());
    }


    // 清理工作
    // close(fd) 由 evbuffer_add_file 内部处理，无需手动关闭
    if (download_path != info.storage_path_) {
        remove(download_path.c_str()); // 删除临时解压文件
    }
}